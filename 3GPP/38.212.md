# 5G NR Multiplexing and Channel Coding

```
Input: MAC PDU (bytes)
        ↓
┌────────────────────────────────────┐
│ CRC Attachment                    │
│ File: crc_byte.c                  │
│ Output: bits + CRC                │
│ Standard: 5.1 CRC calculation     │
└────────────────────────────────────┘
        ↓
┌────────────────────────────────────┐
│ Physical-layer HARQ Processing    │
│ File: Internal buffer or HARQ buffer operations │
│ Output: encoded bits              │
└────────────────────────────────────┘
        ↓
┌────────────────────────────────────┐
│ Segmentation                      │
│ File: nr_segmentation.c           │
│ Output: LDPC Segments (bits)      │
│ Standard: 5.2 Code block segmentation and code block CRC attachment │
└────────────────────────────────────┘
        ↓
┌────────────────────────────────────┐
│ LDPC Encoding                     │
│ File: nr_dlsch_coding.c, CODING/  │
│ Output: encoded bits              │
│ Standard: 5.2.2 Low Density Parity Check Coding │
└────────────────────────────────────┘
        ↓
┌────────────────────────────────────┐
│ Rate Matching + Interleaving      │
│ File: coding/nrRateMatch.c        │
│ Output: RM bits                   │
│ Standard: 6.2.5 Rate Matching     │
└────────────────────────────────────┘
        ↓
┌────────────────────────────────────┐
│ Scrambling                        │
│ File: nr_scrambling.c             │
│ Output: scrambled bits (RM bits)  │
└────────────────────────────────────┘
        ↓
┌────────────────────────────────────┐
│ Modulation (QPSK, 16QAM…)         │
│ File: modulation/nr_modulation.c  │
│ Output: complex symbols (IQ)      │
└────────────────────────────────────┘
        ↓
┌────────────────────────────────────┐
│ Resource Grid Mapping             │
│ File: mapping/nr_ulsch_modulation.c │
│ Output: mapped IQ symbols         │
└────────────────────────────────────┘
        ↓
┌────────────────────────────────────┐
│ DMRS Insertion (UE uplink reference) │
│ File: nr_generate_dmrs.c          │
│ Output: IQ with DMRS              │
│ Standard: 6.2.7 Data & Control Mux │
└────────────────────────────────────┘
        ↓
┌────────────────────────────────────┐
│ DFT-s-OFDM IFFT + CP Insertion    │
│ File: ofdm_mod.c                  │
│ Output: time-domain samples       │
└────────────────────────────────────┘
        ↓
┌────────────────────────────────────┐
│ Channel Simulation (AWGN, fading...) │
│ File: channel_model.c or experimental platform │
│ Output: RX samples                │
└────────────────────────────────────┘
```

## CH4 Mapping to Physical Channels
### Uplink

```markdown
| Transport Channel (TrCH)          | Corresponding Physical Channel                     |
|-----------------------------------|--------------------------------------------------|
| UL-SCH (Uplink-Shared Channel)    | PUSCH (Physical Uplink Shared Channel)           |
| RACH (Random Access Channel)      | PRACH (Physical Random Access Channel)           |
```

### Downlink

```markdown
| Transport Channel (TrCH)          | Corresponding Physical Channel                     |
|-----------------------------------|--------------------------------------------------|
| DL-SCH (Downlink-Shared Channel)  | PDSCH (Physical Downlink Shared Channel)         |
| BCH (Broadcast Channel)           | PBCH (Physical Broadcast Channel)                |
```

## CH5 General Procedures

- The channel coding scheme combines error detection, error correction, rate matching, interleaving, and the mapping or splitting of transport channel or control information onto/from physical channels.

### 5.1 CRC Calculation

- **Systematic Form Encoding**: The original data is retained as is, with CRC appended at the end.
- The parity bits are generated by one of the following cyclic generator polynomials:

  ![image](https://github.com/user-attachments/assets/4bbee2e3-d5fb-4182-a2dd-5f486e6772bc)

- Treat the input data bits as a polynomial:

  ![image](https://github.com/user-attachments/assets/17923298-a7ba-4fcb-8a21-aedbbe89f418)

  Shift the data left by L bits (reserving space for CRC), divide by `g(x)`, and take the remainder (`R(x)`) as the parity bits (CRC). The final transmitted data is:

  ![image](https://github.com/user-attachments/assets/feeb794b-9659-4057-82bf-a83733cc7c21)

- **Transmitter**: Generates parity bits as described and appends them to the data.
- **Receiver**: Repeats the polynomial division: `T(x) mod g(x)`:
  - If the remainder is 0 → Data is error-free.
  - If the remainder ≠ 0 → Errors are detected.

### 5.2 Code Block Segmentation and Code Block CRC Attachment

#### 5.2.2 Low Density Parity Check Coding

```markdown
| Base Graph | Maximum Code Block Length $K_{cb}$ |
|------------|------------------------------------|
| BG1        | 8448 bits                          |
| BG2        | 3840 bits                          |
```

- **STEP 1**:
  - If `B > Kcb`:
    - Divide the data into `C` code blocks.
    - Append `L = 24` bits of CRC24B to each segment.
  - Else:
    - `C = 1`
    - No CRC added (`L = 0`).
    - `B' = B`

- **STEP 2**:
  - `C = ⎡B/(Kcb−24)⎤` ← Ceiling (round up).
  - `B' = B + 24×C` ← Total length after adding all CRC bits.
  - Total length per block: `K = B'/C`, with actual input to LDPC encoding being `K' = K - 24` (CRC length).

- **STEP 3**: Find the smallest `Z` satisfying `Z × Kb ≥ K'`:
  - For BG1: `Kb = 22`
  - For BG2:

```markdown
| BG2 Condition      | Kb Value |
|--------------------|----------|
| B > 640            | 10       |
| 560 < B ≤ 640      | 9        |
| 192 < B ≤ 560      | 8        |
| B ≤ 192            | 6        |
```

  ![image](https://github.com/user-attachments/assets/b5226c6a-bd58-4050-bbcb-b2b010cf4af2)

  From this table, find `Zc` and `iLs`:

  ![image](https://github.com/user-attachments/assets/5ebb2d9d-1e65-4387-bfe2-8d3fe7c6ec3a)

- **STEP 4**: Using `BG` and `iLs`, locate the corresponding `H_BG` matrix. For example, for BG1, `H_BG` is a 46×68 matrix, with each element expanded into a `Zc×Zc` identity matrix, where the number represents the shift value.

- **STEP 5**: Using `Zc` as an example, obtain a final matrix `H` of size `46×384 rows × 68×384 columns` (total `17664 × 26112`).

- **STEP 6**: Define the codeword bit vector: `d = [d0, d1, ..., d26111]`. Input data (`C = 8448 bits`) is inserted starting from `d`'s `2×384`th bit:
  - Codeword `d[0:26111] = [d[0] ~ d[767]] ---- [d[768] ~ d[9215]] ---- [d[9216] ~ d[26111]]`
    - Parity bits: `d[0] ~ d[767]`
    - Data: `c[0] ~ c[8447]`
    - Padding (NULL): `d[9216] ~ d[26111]`

- **STEP 7**: Ensure `H ⋅ d^T = 0`
  - Implementation: Split `H` into two parts: `H = [Hp | Hs]`
    - `Hp`: First 768 columns (parity bits).
    - `Hs`: Last 8448 columns (data bits).
    - Substitute data part and solve: `Hp ⋅ W^T = Hs ⋅ C^T` => `W = (Hp^-1) ⋅ (Hs ⋅ C^T)`
    - `W = [w0...w767] = [d0...d767]` (In practice, direct inversion is avoided; Gaussian elimination or similar methods, such as XOR summation in OAI, are used.)

### 5.4 Rate Matching

#### 5.4.2 Rate Matching for LDPC Code

Rate Matching is applied to each LDPC-encoded code block:

- **1. Bit Selection**:
  - Input: LDPC-encoded bit sequence `d[0] ... d[N-1]`, written into a circular buffer of length `Ncb`.
  - If `LBRM = 0`, then `Ncb = N`; otherwise, `Ncb = min(N, Nref)`.
  - **Note**: `Nref` is calculated based on base graph, TBS, number of layers, modulation order, coding rate, etc. (see TS 38.214).

- **2. Bit Interleaving**:
  - Interleaves the selected `E` bits `e[0] ~ e[E-1]` to produce `f[0] ~ f[E-1]`.
  - Interleaving order is determined by the modulation order `Qm` (e.g., QPSK=2, 16QAM=4, 64QAM=6, 256QAM=8).

## CH6 Uplink Transport Channels and Control Information

### 6.2 Uplink Shared Channel

#### 6.2.2 LDPC Base Graph Selection

- Selects Base Graph based on payload size `A` (including CRC) and code rate `R` (determined by MCS):
  - Use **Base Graph 2 (BG2)** if:
    - `A ≤ 292`, or
    - `A ≤ 3824` and `R ≤ 0.67`, or
    - `R ≤ 0.25`.
  - Otherwise, use **Base Graph 1 (BG1)**.

#### 6.2.5 Rate Matching

- **Input**: `d₀^{(r)}, ..., d_{N_r -1}^{(r)}`
  - Each code block (CB) undergoes Rate Matching independently (refer to 5.4.2).
  - Determines whether Limited Buffer Rate Matching (LBRM) is enabled based on the higher-layer parameter `rateMatching`:
    - `rateMatching = limitedBufferRM` ⇒ `I_LBRM = 1`
    - Otherwise, `I_LBRM = 0`
- **Output**: `f₀^{(r)}, ..., f_{E_r -1}^{(r)}` (each CB results in `E_r` bits after matching).

```plaintext
Transport Block (B bits, including CRC)
        ↓
[6.2.3] Code Block Segmentation + CB CRC
        ↓
[6.2.4] LDPC Encoding (per CB)
        ↓
[6.2.5] Rate Matching (per CB)
        ↓
[6.2.6] CB Concatenation
        ↓
Final Uplink Transmitted Bits g₀, ..., g_{G-1}
```

#### 6.2.7 Data and Control Multiplexing

- Combines UL-SCH and control information (HARQ-ACK, CSI, CG-UCI) in PUSCH into a single encoded bit sequence, mapped to resource elements of OFDM symbols and subcarriers.
- Considers the following factors:
  - **Frequency Hopping**:

    ![image](https://github.com/user-attachments/assets/47360570-d41b-415b-8c1c-ea8a58e22de3)

  - **DMRS Symbol Impact**: DMRS symbols do not carry UCI.
  - **Control Information Priority**: HARQ-ACK has higher priority than CSI.

    ![image](https://github.com/user-attachments/assets/1bc23d8e-7e2c-460c-a125-1a99716e969c)

  - **Influence of Modulation Order `Qm` and Number of Transmission Layers `NL`**:

    ![image](https://github.com/user-attachments/assets/56a0c142-6baa-4cc4-8c59-1a36fd9fef92)

- Divided into 6 steps:
  - **Step 1**: Initialize resource sets and reserve resources for HARQ-ACK.
  - **Step 2**: Prioritize HARQ-ACK (or joint encoding with CG-UCI), allocating UCI resources.
  - **Step 2A**: Handle standalone CG-UCI, allocating UCI resources.
  - **Step 3**: Process CSI Part 1 and Part 2 sequentially, allocating remaining UCI resources.
  - **Step 4**: Map UL-SCH data to the remaining UL-SCH resources.
  - **Step 5**: Handle small HARQ-ACK (≤ 2 bits) using reserved resources.
  - **Step 6**: Generate the final sequence, completing the mapping of all bits.
